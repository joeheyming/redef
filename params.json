{"name":"Redef","tagline":"Python module to redefine a function/attribute of a module that will reset after going out of scope.  You can redef any attribute of an object.  You can also capture input to a redefined function, and other stats.  This tool was inspired by http://search.cpan.org/~airwave/Test-Resub-1.02/lib/Test/Resub.pm  See the test_redef.py for examples.","body":"# Redef\r\n\r\nTo install, just run:\r\n\r\n```bash\r\npython setup.py build\r\npython setup.py install\r\n```\r\n\r\nSee [`test_redef.py`](/joeheyming/redef/blob/master/test_redef.py) under your install path for examples.\r\n\r\nRedef is intended to create lexically scoped variables, that when destroyed, undo mock behavior.\r\nIt was inspired by a Perl module, [Test::Resub](http://search.cpan.org/~airwave/Test-Resub-1.02/lib/Test/Resub.pm)\r\n\r\nThe best examples use `unittest`, but it should work with any testing framework.\r\n\r\n```python\r\nimport unittest\r\nfrom redef import redef\r\n\r\nclass MyClass:\r\n    def lame_function(self):\r\n        return \"something I don't want\"\r\n\r\nclass MyTest(unittest.TestCase):\r\n    def test1(self):\r\n        myobj = MyClass()\r\n        self.assertEqual(myobj.lame_function(), \"something I don't want\")\r\n        want = 'something I want'\r\n        rd_lf = redef(MyClass, 'lame_function', lambda s: want)\r\n        self.assertEqual(myobj.lame_function(), want)\r\n\r\n        # after test1, rd_lf gets deleted and resets\r\n\r\n    def test2(self):        \r\n        myobj = MyClass()\r\n        # test2 is uneffected by test1\r\n        self.assertEqual(myobj.lame_function(), \"something I don't want\")\r\n```\r\n\r\nThis doesn't have to be a function, you can also redefine attributes directly on an object.\r\n\r\n```python\r\nclass MyClass:\r\n      unpredictable = 'random string'\r\n\r\nmy_global_object = MyClass()\r\n\r\nclass MyTest(unittest.TestCase):\r\n     def test3(self):\r\n         rd_u = redef(my_global_object, 'unpredictable', 'unit testable string')\r\n         # ... test something awesome!\r\n         self.assertEqual(my_global_object.unpredictable, 'unit testable string')\r\n\r\n     def test4(self):\r\n         # hey, my_global_object is back to being unpredictable\r\n         self.assertEqual(my_global_object.unpredictable, 'unpredictable')\r\n```\r\n         \r\nThere are other useful functions provided on the redef object itself:\r\n\r\n* Class Redef:\r\n    * `__init__`:\r\n        * takes an object and a key.  The rest of the arguments are kwargs:\r\n        * if the key doesn't exist in the object, an exception will be raised unless you provide kwargs must_exist\r\n        * value: if provided, this value will redefine the key in the object, otherwise you 'wiretap' the object\r\n        * must_call: if provided, when the Redef object is destroyed, it warns if this constraint is violated.\r\n\r\n    * `called()`:\r\n        Stores how many times a redef'd function was called.\r\n    * `method_args()`:\r\n        Stores the most recent `*args` to the redef'd function.\r\n    * `named_method_args()`:\r\n        Stores the most recent `**kwargs` to the redef'd function.\r\n    * `reset()`:\r\n        Sets `called`, `method_args`, and `named_method_args` back to the default state of `0, None, None`\r\n    * `was_called()`:\r\n        Asks the redef object if there was ever a call.  Regardless of calling the reset() function\r\n    * `never_called()`:\r\n        Asks the redef object if there was never a call. Regardless of calling the reset() function\r\n\r\n`Redef` also provides a freebie static function:\r\n\r\n* `redef(obj, key, value)`:\r\n    Static constructor of a `Redef` object\r\n\r\nWhere\r\n  * `obj`: is a Class, Module, or Object you want to temporariliy change\r\n  * `key`: The string name of the attribute you want to change\r\n  * `value`: The new value.  If the value is None, you only capture called, method_args, and named_method_args\r\n   * The None case won't redefine the key on the obj\r\n\r\nThese static functions were provided to show the usefulness of redef: \r\nFor example, you could capture stdout of a function call, and after capturing it,\r\n`sys.stdout` goes back to normal:\r\n\r\n* Class CapturedOutput:\r\n    * Has 2 variables you want: `output`, `returned`\r\n\r\n* Static Functions that return a CapturedOutput:\r\n    * `stdout_of(func, *args, **kwargs)`:\r\n        Call a function and capture the stdout.\r\n        Returns a `CapturedOutput` object that has the stdout and the return value of calling func.\r\n\r\n    * `stderr_of(func, *args, **kwargs)`:\r\n        Call a function and capture the stderr.\r\n        Returns a `CapturedOutput` object that has the stderr and the return value of calling func.\r\n        \r\n* `wiretap`:\r\n    * A static function that creates a Redef object only for the purpose of capturing the method_args and called values.\r\n          * The original functionality should remain the same.\r\n\r\nPlease ask any questions on github: http://github.com/joeheyming/redef/issues\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}